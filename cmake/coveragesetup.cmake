option ( COVERAGE "Record coverage for tests." OFF )
add_library ( coveragedumper INTERFACE )
add_library ( coveragedumperunit INTERFACE )
if ( COVERAGE_SUPPORTED )
  cmake_push_check_state ( RESET )
  set ( CMAKE_REQUIRED_LIBRARIES -Wl,-whole-archive -Wl,-no-whole-archive )
  check_cxx_compiler_flag ( -Wl,-whole-archive ACCEPTS_WHOLE_ARCHIVE )
  cmake_pop_check_state ()

  cmake_push_check_state ( RESET )
  set ( CMAKE_REQUIRED_LIBRARIES -Wl,-u,_main )
  check_cxx_compiler_flag ( -Wall FORCE_DEFINED )
  cmake_pop_check_state ()

  if ( ACCEPTS_WHOLE_ARCHIVE )
    set ( LINK_PREFIX -Wl,-whole-archive )
    set ( LINK_SUFFIX -Wl,-no-whole-archive )
  elseif ( FORCE_DEFINED )
    set ( LINK_SUFFIX_MAIN -Wl,-u,_main_coverage_reset,-u,_main_coverage_dump )
    set ( LINK_SUFFIX_UNIT -Wl,-u,_unit_coverage_reset,-u,_unit_coverage_dump )
  endif ()
  if ( clang IN_LIST COVERAGE_STYLES )
    set ( LIBSUFFIX -clang )
    target_compile_options ( coveragedumper INTERFACE ${CLANG_COVERAGE_FLAGS_LIST} )
    target_compile_options ( coveragedumperunit INTERFACE ${CLANG_COVERAGE_FLAGS_LIST} )
    target_link_libraries ( coveragedumper INTERFACE ${CLANG_COVERAGE_FLAGS_LIST} )
    target_link_libraries ( coveragedumperunit INTERFACE ${CLANG_COVERAGE_FLAGS_LIST} )
  elseif ( gcc IN_LIST COVERAGE_STYLES )
    target_compile_options ( coveragedumper INTERFACE ${GCC_COVERAGE_FLAGS_LIST} )
    target_compile_options ( coveragedumperunit INTERFACE ${GCC_COVERAGE_FLAGS_LIST} )
    target_link_libraries ( coveragedumper INTERFACE ${GCC_COVERAGE_FLAGS_LIST} )
    target_link_libraries ( coveragedumperunit INTERFACE ${GCC_COVERAGE_FLAGS_LIST} )
    set ( LIBSUFFIX -gcc )
  endif ()
  if ( LIBSUFFIX )
    target_link_libraries ( coveragedumper PUBLIC INTERFACE ${LINK_PREFIX} coveragedumper${LIBSUFFIX} ${LINK_SUFFIX} ${LINK_SUFFIX_MAIN} )
    target_link_libraries ( coveragedumperunit PUBLIC INTERFACE ${LINK_PREFIX} coveragedumperunit${LIBSUFFIX} ${LINK_SUFFIX} ${LINK_SUFFIX_UNIT} )
    add_dependencies ( coveragedumper coveragedumper${LIBSUFFIX} )
    add_dependencies ( coveragedumperunit coveragedumperunit${LIBSUFFIX} )
  endif ()
endif ()

function ( dump_target_sources NAME )
  get_target_property ( BINARY_DIR ${NAME} BINARY_DIR )
  get_target_property ( SOURCE_DIR ${NAME} SOURCE_DIR )
  get_target_property ( SOURCES ${NAME} SOURCES )
  get_target_property ( EXCLUDE ${NAME} COVERAGE_EXCLUDE_FILES )
  foreach ( S ${SOURCES} )
    if ( NOT ${S} IN_LIST EXCLUDE )
      string ( FIND ${S} ${CMAKE_BINARY_DIR} out )
      if ( out EQUAL 0 )
      elseif ( IS_ABSOLUTE ${S} )
        set ( FILES "${FILES}${S}\n" )
      else ()
        set ( FILES "${FILES}${SOURCE_DIR}/${S}\n" )
      endif ()
    endif ()
  endforeach ()
  file ( WRITE ${BINARY_DIR}/${NAME}.lst "${FILES}" )
  set ( SOURCE_LIST ${BINARY_DIR}/${NAME}.lst PARENT_SCOPE )
endfunction ()

function ( setup_test_for_coverage TEST COVERS )
  if ( NOT TARGET ${TEST} )
    message ( FATAL_ERROR "No such target ${TEST}" )
  endif ()
  if ( NOT TARGET ${COVERS} )
    message ( FATAL_ERROR "No such target ${COVERS}" )
  endif ()
  get_target_property ( READY_FOR_COVERAGE ${COVERS} READY_FOR_COVERAGE )
  if ( NOT READY_FOR_COVERAGE )
    message ( FATAL_ERROR "Missing call to setup_target_for_coverage on ${COVERS}" )
  endif ()
  target_link_libraries ( ${TEST} PRIVATE coveragedumperunit gtestcoverage )
  cleanup_coverage_files ( ${TEST} )
  dump_target_sources ( ${COVERS} )

  get_target_property ( BINARY_DIR ${COVERS} BINARY_DIR )
  get_target_property ( OUTPUT_NAME ${COVERS} OUTPUT_NAME )
  if ( NOT OUTPUT_NAME )
    set ( OUTPUT_NAME ${COVERS} )
  endif ()
  list ( APPEND OBJECTS_DIRS "${BINARY_DIR}/CMakeFiles/${OUTPUT_NAME}.dir/" )
  get_target_property ( BINARY_DIR ${TEST} BINARY_DIR )
  get_target_property ( OUTPUT_NAME ${TEST} OUTPUT_NAME )
  if ( NOT OUTPUT_NAME )
    set ( OUTPUT_NAME ${TEST} )
  endif ()
  list ( APPEND OBJECTS_DIRS "${BINARY_DIR}/CMakeFiles/${OUTPUT_NAME}.dir/" )
  set_property ( TEST ${TEST} APPEND PROPERTY ENVIRONMENT
                 "CMAKE_BINARY_DIR=${CMAKE_BINARY_DIR}"
                 "SOURCE_LIST=${SOURCE_LIST}"
                 "SOURCE_DIR=${CMAKE_SOURCE_DIR}"
                 "COVERS=${COVERS}"
                 "COVERS_FILE=$<TARGET_FILE:${COVERS}>"
                 "COVERAGE_FILE=${BINARY_DIR}/${OUTPUT_NAME}-coverage.xml"
                 "OBJECTS_DIRS=$<JOIN:${OBJECTS_DIRS},:>" )
  if ( clang IN_LIST COVERAGE_STYLES )
    set_property ( TEST ${TEST} APPEND PROPERTY ENVIRONMENT
                   "LLVM_PROFDATA=${LLVM_PROFDATA_PATH}"
                   "LLVM_SHOW=${LLVM_SHOW_PATH}"
                   )
  elseif ( gcc IN_LIST COVERAGE_STYLES )
    set_property ( TEST ${TEST} APPEND PROPERTY ENVIRONMENT
                   "GCOV=${GCOV_PATH}" )
  endif ()
endfunction ()

function ( cleanup_coverage_files NAME )
  get_target_property ( SOURCES ${NAME} SOURCES )
  get_target_property ( OPTIONAL_SOURCES ${NAME} OPTIONAL_SOURCES )
  list ( APPEND SOURCES ${OPTIONAL_SOURCES} )
  foreach ( S ${SOURCES} )
    set_property ( DIRECTORY ${CMAKE_CURRENT_LIST_DIR} APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES "CMakeFiles/${NAME}.dir/${S}.gcno" )
    set_property ( DIRECTORY ${CMAKE_CURRENT_LIST_DIR} APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES "CMakeFiles/${NAME}.dir/${S}.gcda" )
  endforeach ()
endfunction ()

function ( setup_target_for_coverage NAME )
  cleanup_coverage_files ( ${NAME} )
  #  if ( COVERAGE )
  target_link_libraries ( ${NAME} PRIVATE coveragedumper )
  #  endif ()
  set_target_properties ( ${NAME} PROPERTIES READY_FOR_COVERAGE TRUE )
endfunction ()
